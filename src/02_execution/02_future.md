# Future トレイト

`Future`トレイトは Rust の非同期プログラミングの中心人物です。(超重役だぞ!)

`Future`は値を生成できる非同期計算です。(`()`のような空の値の時もあります)

_簡略化した_`Future`トレイトは以下のようになります。

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:simple_future}}
```

この`poll`関数を呼び出すことで`Future`を進めることが出来ます、これにより、`Future`が可能な限り完了するようになります。`Future`が完了すると`Poll::Ready(result)`を返し、未完了のときは`Poll::Pending`を返して、`Future`がさらに進む準備ができたときに`wake()`関数が呼び出されるように準備します。

`wake()`が呼び出されると、`Future`を駆動するエグゼキューターが`poll`を再度呼び出し、`Future`を更に進めようとします。

`wakte()`がなければ、エグゼキューターは`Future`がいつ進むかを知る方法がなく、つねにすべての`future`をポーリングする必要があります。`wake()`を使用することで、エグゼキューターはどの`Future`を`poll`する準備ができているかを正確に把握できます。

例えば、すでに利用可能なデータが有る場合とない場合があるソケットから読み取りたい場合を考えます。データが有る場合、`Poll::Ready(data)`でそれを読み込んで返すことが出来ます。
しかし、データの準備ができていない時`Future`はブロックされ、進行できなくなります。
データが利用できない時、ソケットでデータの準備ができた時に`wake`が呼び出されるように登録する必要があります。
これにより、エグゼキューターに準備が整ったことが分かります。

単純な`SocketRead`は次のようになります。

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:socket_read}}
```

このモデルでは、中間割当を必要とせずに、複数の非同期オペレーションを一緒に構築できます。 次のように、複数の`Future`を実行したり、連鎖させたりすることは割当のないステートマシンを介して実装できます。

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:join}}
```

これは、個別の割当を必要とせずに複数の`Future`を同時に実行できる方法を示し、より効率的な非同期プログラムを可能にします。同様に、複数のシーケンシャル`Future`を次々に実行することもできます。

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:and_then}}
```

これらの例は複数の割り当てられたオブジェクトと深くネストされたコールバックを必要とせずに、`Future`トレイトを使用して非同期制御フローを表現する方法を示しています。

基本的な制御フローが終わったら、実際の`Future`トレイトと`SimpleFuture`がどのように異なるかを話します。

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:real_future}}
```

気づきやすい最初の変更は`self`がもはや`&mut self`出ないことです。
`Pin<&mut Self>`に変更されました。`Pin`については、[あとのセクション](../04_pinning/01_chapter.md)で詳しくお話します、が、現時点では、`Pin`によって固定した`Future`を作成できることを知っています。固定されたオブジェクトはフィールドなどにポインタを格納できます。`struct MyFut { a: i32, ptr_to_a: *const i32 }`のように。
`async / await`を有効にするにはピン留めが必要になります。

次に、`wake: fn()`は`&mut Context<'_>'`に変更されました。
`SimpleFuture`では関数ポインターの呼び出しを使用して、`Future`をポーリングすることをエグゼキューターに伝えました。しかし、`fn()`はサイズがゼロであるため、`wake`が呼ばれたことなどのデータを保存することができません。

実際は、Web サーバーのような複雑なアプリケーションには起動をすべて個別に管理する必要がある数千の異なる接続が存在する場合があります。
この`Context`タイプは特定のタスクを起動するために使用できる`Waker`へのアクセスを提供することでこれを解決します。
