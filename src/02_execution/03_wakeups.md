# タスクを起こせ！Waker！

`Future`は最初に`poll`された時に完了できないことがよくあります。これが発生した時、`Future`はさらに前進する準備ができたら再度ポーリングされるようにする必要があります。
これは`Waker`型で行われます。

`Future`がポーリングされるたびに、「タスク」の一部としてポーリングされます。
タスクは、エグゼキューターに送信されたトップレベルの`Future`です。

`Waker`は関連付けられたタスクを起動する必要があることをエグゼキューターに伝えるために使用できる`wake()`メソッドを提供します。

`wake()`が呼び出された時、エグゼキューターは、`Waker`と関連するタスクが進む準備が出来たことを知っています。そして、再びポーリングする必要があることも。

`Waker`は`clone()`も実装しているため、コピーして保存することが出来ます。

`Waker`を使用して単純なタイマーを実装してみましょう！

## タイマー作成

この例では、タイマーが作成された時に新しいスレッドを立て、必要な時間だけスリープし、時間経過した時にタイマーの`Future`を通知します。

必要なインポートは次のとおりです。

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:imports}}
```

`Future`の型自体を定義するところからです。私達の future にはスレッドが、タイマーが経過し、future が完了するべきであることを伝える方法が必要です。 `Arc<Mutex<..>>`を使用して、スレッドと future の間で通信します。

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:timer_decl}}
```

実際に`Future`の実装を書いていきましょう！

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:future_for_timer}}
```

かなり簡単ですね。スレッドに`shared_state.completed = true`が設定されている時、完了です！ それ以外の場合`Waker`は現在のタスクのクローンを作成して`shared_state.waker`に渡し、スレッドがタスクを復帰できるようにします。

重要なのは、future が異なる`Waker`を持つ異なるタスクに移動した可能性があるため、future がポーリングされるたびに`Waker`を更新する必要があることです。これは、ポーリングされたあと、タスク間で future が渡される時に発生します。

最後に、実際にタイマーを構築してスレッドを開始する API が必要です。

```rust
{{#include ../../examples/02_03_timer/src/lib.rs:timer_new}}
```

すげぇ！単純なタイマーの future を構築するために必要なのはそれだけです。
さて、future を実行するエグゼキューターがいれば、、、
